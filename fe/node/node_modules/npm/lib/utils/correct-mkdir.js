// XXX this can probably be replaced with gentle-fs.mkdir everywhere it's used
const chownr = require('chownr')
const inflight = require('inflight')
const log = require('npmlog')
const mkdirp = require('mkdirp')
const inferOwner = require('infer-owner')

<<<<<<< HEAD
// retain ownership of the parent dir
// this matches behavior in cacache to infer the cache ownership
// based on the ownership of the cache folder or it is parent.

module.exports = function correctMkdir (path, cb) {
  cb = inflight('correctMkdir: ' + path, cb)
=======
// memoize the directories created by this step
var stats = {}
var effectiveOwner
module.exports = function correctMkdir (path, cb) {
  cb = dezalgo(cb)
  cb = inflight('correctMkdir:' + path, cb)
  if (!cb) {
    return log.verbose('correctMkdir', path, 'correctMkdir already in flight; waiting')
  } else {
    log.verbose('correctMkdir', path, 'correctMkdir not in flight; initializing')
  }

  if (stats[path]) return cb(null, stats[path])

  fs.stat(path, function (er, st) {
    if (er) return makeDirectory(path, cb)

    if (!st.isDirectory()) {
      log.error('correctMkdir', 'invalid dir %s', path)
      return cb(er)
    }

    var ownerStats = calculateOwner()
    // there's always a chance the permissions could have been frobbed, so fix
    if (st.uid !== ownerStats.uid) {
      stats[path] = ownerStats
      setPermissions(path, ownerStats, cb)
    } else {
      stats[path] = st
      cb(null, stats[path])
    }
  })
}

function calculateOwner () {
  if (!effectiveOwner) {
    effectiveOwner = { uid: 0, gid: 0 }

    // Pretty much only on windows
    if (!process.getuid) {
      return effectiveOwner
    }

    effectiveOwner.uid = +process.getuid()
    effectiveOwner.gid = +process.getgid()

    if (effectiveOwner.uid === 0) {
      if (process.env.SUDO_UID) effectiveOwner.uid = +process.env.SUDO_UID
      if (process.env.SUDO_GID) effectiveOwner.gid = +process.env.SUDO_GID
    }
  }

  return effectiveOwner
}

function makeDirectory (path, cb) {
  cb = inflight('makeDirectory:' + path, cb)
>>>>>>> jaeyoung
  if (!cb) {
    return log.verbose('correctMkdir', path, 'correctMkdir already in flight; waiting')
  } else {
    log.verbose('correctMkdir', path, 'correctMkdir not in flight; initializing')
  }

  if (!process.getuid) {
    log.verbose('makeCacheDir', 'UID & GID are irrelevant on', process.platform)
    return mkdirp(path, (er, made) => cb(er, { uid: 0, gid: 0 }))
  }

  inferOwner(path).then(owner => {
    mkdirp(path, (er, made) => {
      if (er) {
        log.error('correctMkdir', 'failed to make directory %s', path)
        return cb(er)
      }
      chownr(made || path, owner.uid, owner.gid, (er) => cb(er, owner))
    })
<<<<<<< HEAD
  }, er => {
    log.error('correctMkdir', 'failed to infer path ownership %s', path)
    return cb(er)
=======
  }

  function afterMkdir (er, made) {
    if (er || !stats[path] || isNaN(stats[path].uid) || isNaN(stats[path].gid)) {
      return cb(er, stats[path])
    }

    if (!made) return cb(er, stats[path])

    setPermissions(made, stats[path], cb)
  }
}

function setPermissions (path, st, cb) {
  chownr(path, st.uid, st.gid, function (er) {
    if (er && er.code === 'ENOENT') return cb(null, st)
    return cb(er, st)
>>>>>>> jaeyoung
  })
}
